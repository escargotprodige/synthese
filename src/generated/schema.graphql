### This file was autogenerated by Nexus 0.9.13
### Do not make changes to this file directly


type AggregateBrand {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateWeaponBase {
  count: Int!
}

type AggregateWeaponPart {
  count: Int!
}

type Attribute {
  name: String!
  value: Float
}

input AttributeCreateInput {
  name: String!
  value: Float
}

input AttributeCreateManyInput {
  create: [AttributeCreateInput!]
}

input AttributeCreateOneInput {
  create: AttributeCreateInput
}

input AttributeRestrictedWhereInput {
  AND: [AttributeRestrictedWhereInput!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  value: Float
  value_gt: Float
  value_gte: Float
  value_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_not: Float
  value_not_in: [Float!]
}

input AttributeScalarWhereInput {
  AND: [AttributeScalarWhereInput!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [AttributeScalarWhereInput!]
  OR: [AttributeScalarWhereInput!]
  value: Float
  value_gt: Float
  value_gte: Float
  value_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_not: Float
  value_not_in: [Float!]
}

input AttributeUpdateManyDataInput {
  name: String
  value: Float
}

input AttributeUpdateManyInput {
  create: [AttributeCreateInput!]
  deleteMany: [AttributeScalarWhereInput!]
  updateMany: [AttributeUpdateManyWithWhereNestedInput!]
}

input AttributeUpdateManyWithWhereNestedInput {
  data: AttributeUpdateManyDataInput!
  where: AttributeScalarWhereInput!
}

input AttributeWhereInput {
  AND: [AttributeWhereInput!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  value: Float
  value_gt: Float
  value_gte: Float
  value_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_not: Float
  value_not_in: [Float!]
}

type BatchPayload {
  count: Long!
}

type Brand {
  id: ID!
  name: String!
  weaponParts(after: String, before: String, first: Int, last: Int, orderBy: WeaponPartOrderByInput, skip: Int, where: WeaponPartWhereInput): [WeaponPart!]
  weapons(after: String, before: String, first: Int, last: Int, orderBy: WeaponBaseOrderByInput, skip: Int, where: WeaponBaseWhereInput): [WeaponBase!]
}

type BrandConnection {
  aggregate: AggregateBrand!
  edges: [BrandEdge!]!
  pageInfo: PageInfo!
}

input BrandCreateInput {
  name: String!
  weaponParts: WeaponPartCreateManyWithoutBrandInput
  weapons: WeaponBaseCreateManyWithoutBrandInput
}

input BrandCreateOneInput {
  connect: BrandWhereUniqueInput
  create: BrandCreateInput
}

input BrandCreateOneWithoutWeaponPartsInput {
  connect: BrandWhereUniqueInput
  create: BrandCreateWithoutWeaponPartsInput
}

input BrandCreateOneWithoutWeaponsInput {
  connect: BrandWhereUniqueInput
  create: BrandCreateWithoutWeaponsInput
}

input BrandCreateWithoutWeaponPartsInput {
  name: String!
  weapons: WeaponBaseCreateManyWithoutBrandInput
}

input BrandCreateWithoutWeaponsInput {
  name: String!
  weaponParts: WeaponPartCreateManyWithoutBrandInput
}

type BrandEdge {
  cursor: String!
  node: Brand!
}

enum BrandOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

input BrandUpdateInput {
  name: String
  weaponParts: WeaponPartUpdateManyWithoutBrandInput
  weapons: WeaponBaseUpdateManyWithoutBrandInput
}

input BrandUpdateManyMutationInput {
  name: String
}

input BrandUpdateOneWithoutWeaponPartsInput {
  connect: BrandWhereUniqueInput
  create: BrandCreateWithoutWeaponPartsInput
  delete: Boolean
  disconnect: Boolean
  update: BrandUpdateWithoutWeaponPartsDataInput
  upsert: BrandUpsertWithoutWeaponPartsInput
}

input BrandUpdateOneWithoutWeaponsInput {
  connect: BrandWhereUniqueInput
  create: BrandCreateWithoutWeaponsInput
  delete: Boolean
  disconnect: Boolean
  update: BrandUpdateWithoutWeaponsDataInput
  upsert: BrandUpsertWithoutWeaponsInput
}

input BrandUpdateWithoutWeaponPartsDataInput {
  name: String
  weapons: WeaponBaseUpdateManyWithoutBrandInput
}

input BrandUpdateWithoutWeaponsDataInput {
  name: String
  weaponParts: WeaponPartUpdateManyWithoutBrandInput
}

input BrandUpsertWithoutWeaponPartsInput {
  create: BrandCreateWithoutWeaponPartsInput!
  update: BrandUpdateWithoutWeaponPartsDataInput!
}

input BrandUpsertWithoutWeaponsInput {
  create: BrandCreateWithoutWeaponsInput!
  update: BrandUpdateWithoutWeaponsDataInput!
}

input BrandWhereInput {
  AND: [BrandWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  weaponParts_some: WeaponPartWhereInput
  weapons_some: WeaponBaseWhereInput
}

input BrandWhereUniqueInput {
  id: ID
}

type Effect {
  AttributeToModify: Attribute
  baseValueAttribute: Attribute
  baseValueConstant: Float
  baseValueScaleConstant: Float
  modifierType: ModifierType
}

input EffectCreateInput {
  AttributeToModify: AttributeCreateOneInput
  baseValueAttribute: AttributeCreateOneInput
  baseValueConstant: Float
  baseValueScaleConstant: Float
  modifierType: ModifierType
}

input EffectCreateManyInput {
  create: [EffectCreateInput!]
}

input EffectRestrictedWhereInput {
  AND: [EffectRestrictedWhereInput!]
  AttributeToModify: AttributeRestrictedWhereInput
  baseValueAttribute: AttributeRestrictedWhereInput
  baseValueConstant: Float
  baseValueConstant_gt: Float
  baseValueConstant_gte: Float
  baseValueConstant_in: [Float!]
  baseValueConstant_lt: Float
  baseValueConstant_lte: Float
  baseValueConstant_not: Float
  baseValueConstant_not_in: [Float!]
  baseValueScaleConstant: Float
  baseValueScaleConstant_gt: Float
  baseValueScaleConstant_gte: Float
  baseValueScaleConstant_in: [Float!]
  baseValueScaleConstant_lt: Float
  baseValueScaleConstant_lte: Float
  baseValueScaleConstant_not: Float
  baseValueScaleConstant_not_in: [Float!]
  modifierType: ModifierType
  modifierType_in: [ModifierType!]
  modifierType_not: ModifierType
  modifierType_not_in: [ModifierType!]
}

input EffectScalarWhereInput {
  AND: [EffectScalarWhereInput!]
  baseValueConstant: Float
  baseValueConstant_gt: Float
  baseValueConstant_gte: Float
  baseValueConstant_in: [Float!]
  baseValueConstant_lt: Float
  baseValueConstant_lte: Float
  baseValueConstant_not: Float
  baseValueConstant_not_in: [Float!]
  baseValueScaleConstant: Float
  baseValueScaleConstant_gt: Float
  baseValueScaleConstant_gte: Float
  baseValueScaleConstant_in: [Float!]
  baseValueScaleConstant_lt: Float
  baseValueScaleConstant_lte: Float
  baseValueScaleConstant_not: Float
  baseValueScaleConstant_not_in: [Float!]
  modifierType: ModifierType
  modifierType_in: [ModifierType!]
  modifierType_not: ModifierType
  modifierType_not_in: [ModifierType!]
  NOT: [EffectScalarWhereInput!]
  OR: [EffectScalarWhereInput!]
}

input EffectUpdateManyDataInput {
  baseValueConstant: Float
  baseValueScaleConstant: Float
  modifierType: ModifierType
}

input EffectUpdateManyInput {
  create: [EffectCreateInput!]
  deleteMany: [EffectScalarWhereInput!]
  updateMany: [EffectUpdateManyWithWhereNestedInput!]
}

input EffectUpdateManyWithWhereNestedInput {
  data: EffectUpdateManyDataInput!
  where: EffectScalarWhereInput!
}

input EffectWhereInput {
  AND: [EffectWhereInput!]
  AttributeToModify: AttributeWhereInput
  baseValueAttribute: AttributeWhereInput
  baseValueConstant: Float
  baseValueConstant_gt: Float
  baseValueConstant_gte: Float
  baseValueConstant_in: [Float!]
  baseValueConstant_lt: Float
  baseValueConstant_lte: Float
  baseValueConstant_not: Float
  baseValueConstant_not_in: [Float!]
  baseValueScaleConstant: Float
  baseValueScaleConstant_gt: Float
  baseValueScaleConstant_gte: Float
  baseValueScaleConstant_in: [Float!]
  baseValueScaleConstant_lt: Float
  baseValueScaleConstant_lte: Float
  baseValueScaleConstant_not: Float
  baseValueScaleConstant_not_in: [Float!]
  modifierType: ModifierType
  modifierType_in: [ModifierType!]
  modifierType_not: ModifierType
  modifierType_not_in: [ModifierType!]
}

scalar Long

enum ModifierType {
  PRE_ADD
  SCALE
}

type Mutation {
  createBrand(data: BrandCreateInput!): Brand!
  createUser(data: UserCreateInput!): User!
  createWeaponBase(data: WeaponBaseCreateInput!): WeaponBase!
  createWeaponPart(data: WeaponPartCreateInput!): WeaponPart!
  deleteBrand(where: BrandWhereUniqueInput!): Brand
  deleteManyBrands(where: BrandWhereInput): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deleteManyWeaponBases(where: WeaponBaseWhereInput): BatchPayload!
  deleteManyWeaponParts(where: WeaponPartWhereInput): BatchPayload!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteWeaponBase(where: WeaponBaseWhereUniqueInput!): WeaponBase
  deleteWeaponPart(where: WeaponPartWhereUniqueInput!): WeaponPart
  updateBrand(data: BrandUpdateInput!, where: BrandWhereUniqueInput!): Brand
  updateManyBrands(data: BrandUpdateManyMutationInput!, where: BrandWhereInput): BatchPayload!
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateManyWeaponBases(data: WeaponBaseUpdateManyMutationInput!, where: WeaponBaseWhereInput): BatchPayload!
  updateManyWeaponParts(data: WeaponPartUpdateManyMutationInput!, where: WeaponPartWhereInput): BatchPayload!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateWeaponBase(data: WeaponBaseUpdateInput!, where: WeaponBaseWhereUniqueInput!): WeaponBase
  updateWeaponPart(data: WeaponPartUpdateInput!, where: WeaponPartWhereUniqueInput!): WeaponPart
  upsertBrand(create: BrandCreateInput!, update: BrandUpdateInput!, where: BrandWhereUniqueInput!): Brand!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertWeaponBase(create: WeaponBaseCreateInput!, update: WeaponBaseUpdateInput!, where: WeaponBaseWhereUniqueInput!): WeaponBase!
  upsertWeaponPart(create: WeaponPartCreateInput!, update: WeaponPartUpdateInput!, where: WeaponPartWhereUniqueInput!): WeaponPart!
}

type NameByBrand {
  brand: Brand
  name: String!
}

input NameByBrandCreateInput {
  brand: BrandCreateOneInput
  name: String!
}

input NameByBrandCreateManyInput {
  create: [NameByBrandCreateInput!]
}

input NameByBrandRestrictedWhereInput {
  AND: [NameByBrandRestrictedWhereInput!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
}

input NameByBrandScalarWhereInput {
  AND: [NameByBrandScalarWhereInput!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [NameByBrandScalarWhereInput!]
  OR: [NameByBrandScalarWhereInput!]
}

input NameByBrandUpdateManyDataInput {
  name: String
}

input NameByBrandUpdateManyInput {
  create: [NameByBrandCreateInput!]
  deleteMany: [NameByBrandScalarWhereInput!]
  updateMany: [NameByBrandUpdateManyWithWhereNestedInput!]
}

input NameByBrandUpdateManyWithWhereNestedInput {
  data: NameByBrandUpdateManyDataInput!
  where: NameByBrandScalarWhereInput!
}

input NameByBrandWhereInput {
  AND: [NameByBrandWhereInput!]
  brand: BrandWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
}

interface Node {
  id: ID!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  brand(where: BrandWhereUniqueInput!): Brand
  brands(after: String, before: String, first: Int, last: Int, orderBy: BrandOrderByInput, skip: Int, where: BrandWhereInput): [Brand!]!
  brandsConnection(after: String, before: String, first: Int, last: Int, orderBy: BrandOrderByInput, skip: Int, where: BrandWhereInput): BrandConnection!
  node(id: ID!): Node
  user(where: UserWhereUniqueInput!): User
  users(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
  usersConnection(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): UserConnection!
  weaponBase(where: WeaponBaseWhereUniqueInput!): WeaponBase
  weaponBases(after: String, before: String, first: Int, last: Int, orderBy: WeaponBaseOrderByInput, skip: Int, where: WeaponBaseWhereInput): [WeaponBase!]!
  weaponBasesConnection(after: String, before: String, first: Int, last: Int, orderBy: WeaponBaseOrderByInput, skip: Int, where: WeaponBaseWhereInput): WeaponBaseConnection!
  weaponPart(where: WeaponPartWhereUniqueInput!): WeaponPart
  weaponParts(after: String, before: String, first: Int, last: Int, orderBy: WeaponPartOrderByInput, skip: Int, where: WeaponPartWhereInput): [WeaponPart!]!
  weaponPartsConnection(after: String, before: String, first: Int, last: Int, orderBy: WeaponPartOrderByInput, skip: Int, where: WeaponPartWhereInput): WeaponPartConnection!
}

enum Rarity {
  COMMON
  LEGENDARY
  RARE
  UNCOMMON
  VERY_RARE
}

type User {
  id: ID!
  name: String!
}

type UserConnection {
  aggregate: AggregateUser!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

input UserCreateInput {
  name: String!
}

type UserEdge {
  cursor: String!
  node: User!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

input UserUpdateInput {
  name: String
}

input UserUpdateManyMutationInput {
  name: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
}

input UserWhereUniqueInput {
  id: ID
}

type WeaponBase {
  attributes: [Attribute!]
  brand: Brand
  id: ID!
  rarity: Rarity
  type: WeaponType
}

type WeaponBaseConnection {
  aggregate: AggregateWeaponBase!
  edges: [WeaponBaseEdge!]!
  pageInfo: PageInfo!
}

input WeaponBaseCreateInput {
  attributes: AttributeCreateManyInput
  brand: BrandCreateOneWithoutWeaponsInput
  rarity: Rarity
  type: WeaponType
}

input WeaponBaseCreateManyWithoutBrandInput {
  connect: [WeaponBaseWhereUniqueInput!]
  create: [WeaponBaseCreateWithoutBrandInput!]
}

input WeaponBaseCreateWithoutBrandInput {
  attributes: AttributeCreateManyInput
  rarity: Rarity
  type: WeaponType
}

type WeaponBaseEdge {
  cursor: String!
  node: WeaponBase!
}

enum WeaponBaseOrderByInput {
  id_ASC
  id_DESC
  rarity_ASC
  rarity_DESC
  type_ASC
  type_DESC
}

input WeaponBaseScalarWhereInput {
  AND: [WeaponBaseScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [WeaponBaseScalarWhereInput!]
  OR: [WeaponBaseScalarWhereInput!]
  rarity: Rarity
  rarity_in: [Rarity!]
  rarity_not: Rarity
  rarity_not_in: [Rarity!]
  type: WeaponType
  type_in: [WeaponType!]
  type_not: WeaponType
  type_not_in: [WeaponType!]
}

input WeaponBaseUpdateInput {
  attributes: AttributeUpdateManyInput
  brand: BrandUpdateOneWithoutWeaponsInput
  rarity: Rarity
  type: WeaponType
}

input WeaponBaseUpdateManyDataInput {
  rarity: Rarity
  type: WeaponType
}

input WeaponBaseUpdateManyMutationInput {
  rarity: Rarity
  type: WeaponType
}

input WeaponBaseUpdateManyWithoutBrandInput {
  connect: [WeaponBaseWhereUniqueInput!]
  create: [WeaponBaseCreateWithoutBrandInput!]
  delete: [WeaponBaseWhereUniqueInput!]
  deleteMany: [WeaponBaseScalarWhereInput!]
  disconnect: [WeaponBaseWhereUniqueInput!]
  set: [WeaponBaseWhereUniqueInput!]
  update: [WeaponBaseUpdateWithWhereUniqueWithoutBrandInput!]
  updateMany: [WeaponBaseUpdateManyWithWhereNestedInput!]
  upsert: [WeaponBaseUpsertWithWhereUniqueWithoutBrandInput!]
}

input WeaponBaseUpdateManyWithWhereNestedInput {
  data: WeaponBaseUpdateManyDataInput!
  where: WeaponBaseScalarWhereInput!
}

input WeaponBaseUpdateWithoutBrandDataInput {
  attributes: AttributeUpdateManyInput
  rarity: Rarity
  type: WeaponType
}

input WeaponBaseUpdateWithWhereUniqueWithoutBrandInput {
  data: WeaponBaseUpdateWithoutBrandDataInput!
  where: WeaponBaseWhereUniqueInput!
}

input WeaponBaseUpsertWithWhereUniqueWithoutBrandInput {
  create: WeaponBaseCreateWithoutBrandInput!
  update: WeaponBaseUpdateWithoutBrandDataInput!
  where: WeaponBaseWhereUniqueInput!
}

input WeaponBaseWhereInput {
  AND: [WeaponBaseWhereInput!]
  attributes_every: AttributeRestrictedWhereInput
  attributes_none: AttributeRestrictedWhereInput
  attributes_some: AttributeWhereInput
  brand: BrandWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  rarity: Rarity
  rarity_in: [Rarity!]
  rarity_not: Rarity
  rarity_not_in: [Rarity!]
  type: WeaponType
  type_in: [WeaponType!]
  type_not: WeaponType
  type_not_in: [WeaponType!]
}

input WeaponBaseWhereUniqueInput {
  id: ID
}

type WeaponPart {
  brand: Brand
  effects: [Effect!]
  id: ID!
  partType: WeaponPartType
  prefixes: [NameByBrand!]
  titles: [NameByBrand!]
  weaponType: WeaponType
}

type WeaponPartConnection {
  aggregate: AggregateWeaponPart!
  edges: [WeaponPartEdge!]!
  pageInfo: PageInfo!
}

input WeaponPartCreateInput {
  brand: BrandCreateOneWithoutWeaponPartsInput
  effects: EffectCreateManyInput
  partType: WeaponPartType
  prefixes: NameByBrandCreateManyInput
  titles: NameByBrandCreateManyInput
  weaponType: WeaponType
}

input WeaponPartCreateManyWithoutBrandInput {
  connect: [WeaponPartWhereUniqueInput!]
  create: [WeaponPartCreateWithoutBrandInput!]
}

input WeaponPartCreateWithoutBrandInput {
  effects: EffectCreateManyInput
  partType: WeaponPartType
  prefixes: NameByBrandCreateManyInput
  titles: NameByBrandCreateManyInput
  weaponType: WeaponType
}

type WeaponPartEdge {
  cursor: String!
  node: WeaponPart!
}

enum WeaponPartOrderByInput {
  id_ASC
  id_DESC
  partType_ASC
  partType_DESC
  weaponType_ASC
  weaponType_DESC
}

input WeaponPartScalarWhereInput {
  AND: [WeaponPartScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [WeaponPartScalarWhereInput!]
  OR: [WeaponPartScalarWhereInput!]
  partType: WeaponPartType
  partType_in: [WeaponPartType!]
  partType_not: WeaponPartType
  partType_not_in: [WeaponPartType!]
  weaponType: WeaponType
  weaponType_in: [WeaponType!]
  weaponType_not: WeaponType
  weaponType_not_in: [WeaponType!]
}

enum WeaponPartType {
  ACCESSORY
  BARREL
  BODY
  GRIP
  SIGHT
  STOCK
}

input WeaponPartUpdateInput {
  brand: BrandUpdateOneWithoutWeaponPartsInput
  effects: EffectUpdateManyInput
  partType: WeaponPartType
  prefixes: NameByBrandUpdateManyInput
  titles: NameByBrandUpdateManyInput
  weaponType: WeaponType
}

input WeaponPartUpdateManyDataInput {
  partType: WeaponPartType
  weaponType: WeaponType
}

input WeaponPartUpdateManyMutationInput {
  partType: WeaponPartType
  weaponType: WeaponType
}

input WeaponPartUpdateManyWithoutBrandInput {
  connect: [WeaponPartWhereUniqueInput!]
  create: [WeaponPartCreateWithoutBrandInput!]
  delete: [WeaponPartWhereUniqueInput!]
  deleteMany: [WeaponPartScalarWhereInput!]
  disconnect: [WeaponPartWhereUniqueInput!]
  set: [WeaponPartWhereUniqueInput!]
  update: [WeaponPartUpdateWithWhereUniqueWithoutBrandInput!]
  updateMany: [WeaponPartUpdateManyWithWhereNestedInput!]
  upsert: [WeaponPartUpsertWithWhereUniqueWithoutBrandInput!]
}

input WeaponPartUpdateManyWithWhereNestedInput {
  data: WeaponPartUpdateManyDataInput!
  where: WeaponPartScalarWhereInput!
}

input WeaponPartUpdateWithoutBrandDataInput {
  effects: EffectUpdateManyInput
  partType: WeaponPartType
  prefixes: NameByBrandUpdateManyInput
  titles: NameByBrandUpdateManyInput
  weaponType: WeaponType
}

input WeaponPartUpdateWithWhereUniqueWithoutBrandInput {
  data: WeaponPartUpdateWithoutBrandDataInput!
  where: WeaponPartWhereUniqueInput!
}

input WeaponPartUpsertWithWhereUniqueWithoutBrandInput {
  create: WeaponPartCreateWithoutBrandInput!
  update: WeaponPartUpdateWithoutBrandDataInput!
  where: WeaponPartWhereUniqueInput!
}

input WeaponPartWhereInput {
  AND: [WeaponPartWhereInput!]
  brand: BrandWhereInput
  effects_every: EffectRestrictedWhereInput
  effects_none: EffectRestrictedWhereInput
  effects_some: EffectWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  partType: WeaponPartType
  partType_in: [WeaponPartType!]
  partType_not: WeaponPartType
  partType_not_in: [WeaponPartType!]
  prefixes_every: NameByBrandRestrictedWhereInput
  prefixes_none: NameByBrandRestrictedWhereInput
  prefixes_some: NameByBrandWhereInput
  titles_every: NameByBrandRestrictedWhereInput
  titles_none: NameByBrandRestrictedWhereInput
  titles_some: NameByBrandWhereInput
  weaponType: WeaponType
  weaponType_in: [WeaponType!]
  weaponType_not: WeaponType
  weaponType_not_in: [WeaponType!]
}

input WeaponPartWhereUniqueInput {
  id: ID
}

enum WeaponType {
  ASSAULT_RIFLE
  PISTOL
  ROCKET_LAUNCHER
  SHOTGUN
  SMG
  SNIPER
}
