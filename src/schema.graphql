### This file was autogenerated by Nexus 0.11.6
### Do not make changes to this file directly


type AggregateBrand {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateWeaponBase {
  count: Int!
}

type AggregateWeaponPart {
  count: Int!
}

type Attribute {
  id: ID!
  name: String!
  value: Float!
}

input AttributeRestrictedWhereInput {
  AND: [AttributeRestrictedWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  value: Float
  value_gt: Float
  value_gte: Float
  value_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_not: Float
  value_not_in: [Float!]
}

input AttributeWhereInput {
  AND: [AttributeWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  value: Float
  value_gt: Float
  value_gte: Float
  value_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_not: Float
  value_not_in: [Float!]
}

type Brand {
  id: ID!
  name: String!
  weaponParts(after: String, before: String, first: Int, last: Int, orderBy: WeaponPartOrderByInput, skip: Int, where: WeaponPartWhereInput): [WeaponPart!]
  weapons(after: String, before: String, first: Int, last: Int, orderBy: WeaponBaseOrderByInput, skip: Int, where: WeaponBaseWhereInput): [WeaponBase!]
}

type BrandConnection {
  aggregate: AggregateBrand!
  edges: [BrandEdge!]!
  pageInfo: PageInfo!
}

type BrandEdge {
  cursor: String!
  node: Brand!
}

enum BrandOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

input BrandWhereInput {
  AND: [BrandWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  weaponParts_some: WeaponPartWhereInput
  weapons_some: WeaponBaseWhereInput
}

input BrandWhereUniqueInput {
  id: ID
}

type Effect {
  AttributeToModify: Attribute
  baseValueAttribute: Attribute
  baseValueConstant: Float
  baseValueScaleConstant: Float
  id: ID!
  modifierType: ModifierType
}

input EffectRestrictedWhereInput {
  AND: [EffectRestrictedWhereInput!]
  AttributeToModify: AttributeRestrictedWhereInput
  baseValueAttribute: AttributeRestrictedWhereInput
  baseValueConstant: Float
  baseValueConstant_gt: Float
  baseValueConstant_gte: Float
  baseValueConstant_in: [Float!]
  baseValueConstant_lt: Float
  baseValueConstant_lte: Float
  baseValueConstant_not: Float
  baseValueConstant_not_in: [Float!]
  baseValueScaleConstant: Float
  baseValueScaleConstant_gt: Float
  baseValueScaleConstant_gte: Float
  baseValueScaleConstant_in: [Float!]
  baseValueScaleConstant_lt: Float
  baseValueScaleConstant_lte: Float
  baseValueScaleConstant_not: Float
  baseValueScaleConstant_not_in: [Float!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  modifierType: ModifierType
  modifierType_in: [ModifierType!]
  modifierType_not: ModifierType
  modifierType_not_in: [ModifierType!]
}

input EffectWhereInput {
  AND: [EffectWhereInput!]
  AttributeToModify: AttributeWhereInput
  baseValueAttribute: AttributeWhereInput
  baseValueConstant: Float
  baseValueConstant_gt: Float
  baseValueConstant_gte: Float
  baseValueConstant_in: [Float!]
  baseValueConstant_lt: Float
  baseValueConstant_lte: Float
  baseValueConstant_not: Float
  baseValueConstant_not_in: [Float!]
  baseValueScaleConstant: Float
  baseValueScaleConstant_gt: Float
  baseValueScaleConstant_gte: Float
  baseValueScaleConstant_in: [Float!]
  baseValueScaleConstant_lt: Float
  baseValueScaleConstant_lte: Float
  baseValueScaleConstant_not: Float
  baseValueScaleConstant_not_in: [Float!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  modifierType: ModifierType
  modifierType_in: [ModifierType!]
  modifierType_not: ModifierType
  modifierType_not_in: [ModifierType!]
}

enum ModifierType {
  PRE_ADD
  SCALE
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Prefix {
  id: ID!
  name: String!
  priority: Int!
}

input PrefixRestrictedWhereInput {
  AND: [PrefixRestrictedWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  priority: Int
  priority_gt: Int
  priority_gte: Int
  priority_in: [Int!]
  priority_lt: Int
  priority_lte: Int
  priority_not: Int
  priority_not_in: [Int!]
}

input PrefixWhereInput {
  AND: [PrefixWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  priority: Int
  priority_gt: Int
  priority_gte: Int
  priority_in: [Int!]
  priority_lt: Int
  priority_lte: Int
  priority_not: Int
  priority_not_in: [Int!]
}

type Query {
  brand(where: BrandWhereUniqueInput!): Brand
  brands(after: String, before: String, first: Int, last: Int, orderBy: BrandOrderByInput, skip: Int, where: BrandWhereInput): [Brand!]!
  brandsConnection(after: String, before: String, first: Int, last: Int, orderBy: BrandOrderByInput, skip: Int, where: BrandWhereInput): BrandConnection!
  user(where: UserWhereUniqueInput!): User
  users(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
  usersConnection(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): UserConnection!
  weapon(weaponInput: WeaponInput): Weapon
  weaponBase(where: WeaponBaseWhereUniqueInput!): WeaponBase
  weaponBases(after: String, before: String, first: Int, last: Int, orderBy: WeaponBaseOrderByInput, skip: Int, where: WeaponBaseWhereInput): [WeaponBase!]!
  weaponBasesConnection(after: String, before: String, first: Int, last: Int, orderBy: WeaponBaseOrderByInput, skip: Int, where: WeaponBaseWhereInput): WeaponBaseConnection!
  weaponPart(where: WeaponPartWhereUniqueInput!): WeaponPart
  weaponParts(after: String, before: String, first: Int, last: Int, orderBy: WeaponPartOrderByInput, skip: Int, where: WeaponPartWhereInput): [WeaponPart!]!
  weaponPartsConnection(after: String, before: String, first: Int, last: Int, orderBy: WeaponPartOrderByInput, skip: Int, where: WeaponPartWhereInput): WeaponPartConnection!
}

type Title {
  brand: Brand
  id: ID!
  name: String!
}

input TitleRestrictedWhereInput {
  AND: [TitleRestrictedWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
}

input TitleWhereInput {
  AND: [TitleWhereInput!]
  brand: BrandWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
}

type User {
  id: ID!
  name: String!
}

type UserConnection {
  aggregate: AggregateUser!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

type UserEdge {
  cursor: String!
  node: User!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

input UserWhereInput {
  AND: [UserWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
}

input UserWhereUniqueInput {
  id: ID
}

type Weapon {
  level: Int
  name: String
}

type WeaponBase {
  attributes: [Attribute!]
  brand: Brand
  id: ID!
  weaponType: WeaponType!
}

type WeaponBaseConnection {
  aggregate: AggregateWeaponBase!
  edges: [WeaponBaseEdge!]!
  pageInfo: PageInfo!
}

type WeaponBaseEdge {
  cursor: String!
  node: WeaponBase!
}

enum WeaponBaseOrderByInput {
  id_ASC
  id_DESC
  weaponType_ASC
  weaponType_DESC
}

input WeaponBaseWhereInput {
  AND: [WeaponBaseWhereInput!]
  attributes_every: AttributeRestrictedWhereInput
  attributes_none: AttributeRestrictedWhereInput
  attributes_some: AttributeWhereInput
  brand: BrandWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  weaponType: WeaponType
  weaponType_in: [WeaponType!]
  weaponType_not: WeaponType
  weaponType_not_in: [WeaponType!]
}

input WeaponBaseWhereUniqueInput {
  id: ID
}

input WeaponInput {
  level: Int
  weaponBase: WeaponBaseWhereUniqueInput
  weaponParts: [WeaponPartWhereInput!]
}

type WeaponPart {
  brand: Brand
  effects: [Effect!]
  id: ID!
  partType: WeaponPartType
  prefixes: [Prefix!]
  titles: [Title!]
  weaponType: WeaponType
}

type WeaponPartConnection {
  aggregate: AggregateWeaponPart!
  edges: [WeaponPartEdge!]!
  pageInfo: PageInfo!
}

type WeaponPartEdge {
  cursor: String!
  node: WeaponPart!
}

enum WeaponPartOrderByInput {
  id_ASC
  id_DESC
  partType_ASC
  partType_DESC
  weaponType_ASC
  weaponType_DESC
}

enum WeaponPartType {
  ACCESSORY
  BARREL
  BODY
  ELEMENTAL
  GRIP
  SIGHT
  STOCK
}

input WeaponPartWhereInput {
  AND: [WeaponPartWhereInput!]
  brand: BrandWhereInput
  effects_every: EffectRestrictedWhereInput
  effects_none: EffectRestrictedWhereInput
  effects_some: EffectWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  partType: WeaponPartType
  partType_in: [WeaponPartType!]
  partType_not: WeaponPartType
  partType_not_in: [WeaponPartType!]
  prefixes_every: PrefixRestrictedWhereInput
  prefixes_none: PrefixRestrictedWhereInput
  prefixes_some: PrefixWhereInput
  titles_every: TitleRestrictedWhereInput
  titles_none: TitleRestrictedWhereInput
  titles_some: TitleWhereInput
  weaponType: WeaponType
  weaponType_in: [WeaponType!]
  weaponType_not: WeaponType
  weaponType_not_in: [WeaponType!]
}

input WeaponPartWhereUniqueInput {
  id: ID
}

enum WeaponType {
  ASSAULT_RIFLE
  PISTOL
  ROCKET_LAUNCHER
  SHOTGUN
  SMG
  SNIPER
}
